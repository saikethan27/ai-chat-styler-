---
phase: 04-ui-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - background.js
autonomous: true

must_haves:
  truths:
    - "Service worker maintains per-site enabled/disabled state"
    - "Extension badge shows active (colored) or inactive (gray) state"
    - "Settings persist across browser restarts via chrome.storage.sync"
    - "Content script can query current site state from background"
    - "State changes propagate to all tabs of the same site"
  artifacts:
    - path: "background.js"
      provides: "Service worker with state management, storage, and badge updates"
      exports: ["getSiteState", "setSiteState", "updateBadge"]
  key_links:
    - from: "background.js"
      to: "chrome.storage.sync"
      via: "chrome.storage.sync.get/set API"
      pattern: "chrome\.storage\.sync"
    - from: "background.js"
      to: "chrome.action.setBadge"
      via: "Badge update API"
      pattern: "chrome\.action\.setBadge"
---

<objective>
Implement the background service worker with per-site state management, chrome.storage.sync persistence, and badge updates.

Purpose: Centralize state management so the extension can track which sites are enabled/disabled and persist these preferences across sessions.
Output: Fully functional background.js with state management API, storage integration, and badge control.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Current State

The background.js is currently a placeholder with just console.log on install and TODO comments. It needs full implementation for Phase 4.

## Requirements to Implement

- BKGD-01: Service worker state management
- BKGD-02: Per-site state persistence
- BKGD-03: Badge updates

## Key Technical Details

- Uses chrome.storage.sync for settings (permission already in manifest)
- Manifest V3 with service_worker background type
- Badge should show active (colored icon state) vs inactive (gray)
- State structure: { sites: { "gemini.google.com": { enabled: true, theme: "auto" } } }
- Console prefix standard: '[Claude UI Extension]'

## Existing Code Reference

Current background.js:
```javascript
// Background service worker for Claude UI/UX Extension
// Phase 4 will implement full state management

chrome.runtime.onInstalled.addListener(() => {
  console.log('Claude UI/UX Extension installed');
});

// Placeholder for Phase 4 implementation
// TODO: Implement per-site state management
// TODO: Implement badge updates
// TODO: Implement popup communication
```

Manifest already has:
- "permissions": ["activeTab", "scripting", "storage"]
- "background": { "service_worker": "background.js" }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement state management and storage in background.js</name>
  <files>background.js</files>
  <action>
Replace the placeholder background.js with full state management implementation:

1. Add LOG_PREFIX constant: '[Claude UI Extension]'

2. Create default state structure:
   ```javascript
   const DEFAULT_STATE = {
     sites: {},  // Per-site settings: { "hostname": { enabled: true, theme: "auto" } }
     global: {
       defaultEnabled: true,  // New sites enabled by default
       defaultTheme: "auto"   // "auto" | "light" | "dark"
     }
   };
   ```

3. Implement getSiteState(hostname) function:
   - Returns { enabled: boolean, theme: string } for given hostname
   - Uses global defaults if site not in storage
   - Async function using chrome.storage.sync

4. Implement setSiteState(hostname, settings) function:
   - Updates settings for specific hostname
   - Merges with existing settings (don't overwrite unspecified fields)
   - Persists to chrome.storage.sync
   - Triggers badge update after state change

5. Implement getAllSettings() function:
   - Returns entire settings object from storage
   - Used by popup to show global settings

6. Implement updateBadge(tabId, enabled) function:
   - Uses chrome.action.setBadgeText({ text: enabled ? '' : 'OFF' })
   - Uses chrome.action.setBadgeBackgroundColor({ color: '#999999' }) when OFF
   - Clears badge when enabled

7. Set up message handlers for content script and popup:
   - getSiteState: { action: 'getSiteState', hostname: string }
   - setSiteState: { action: 'setSiteState', hostname: string, enabled: boolean, theme: string }
   - getAllSettings: { action: 'getAllSettings' }

8. Handle tab activation and URL changes:
   - Listen for chrome.tabs.onActivated
   - Listen for chrome.tabs.onUpdated (url changes)
   - Update badge based on current site's enabled state

9. Initialize storage on install:
   - Set default state if no existing settings
   - Log initialization with LOG_PREFIX

Implementation notes:
- All storage operations must use chrome.storage.sync (not local)
- Handle errors gracefully with try/catch
- Use async/await for all storage operations
- Badge text '' means no badge (clean icon), 'OFF' means disabled
  </action>
  <verify>
1. Check background.js loads without errors in Chrome DevTools (chrome://extensions -> service worker)
2. Verify chrome.storage.sync.set/get work by checking Storage tab in DevTools
3. Test badge updates by manually calling updateBadge from console
4. Verify message handlers respond correctly:
   ```javascript
   chrome.runtime.sendMessage({ action: 'getSiteState', hostname: 'example.com' })
   ```
  </verify>
  <done>
- background.js has complete state management implementation
- getSiteState, setSiteState, getAllSettings functions work correctly
- Badge updates show 'OFF' when disabled, nothing when enabled
- Settings persist in chrome.storage.sync
- Message handlers respond to getSiteState, setSiteState, getAllSettings
- Tab activation triggers badge update
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tab tracking and automatic badge synchronization</name>
  <files>background.js</files>
  <action>
Extend background.js with automatic badge synchronization across tabs:

1. Implement updateBadgeForTab(tabId) function:
   - Get tab URL via chrome.tabs.get(tabId)
   - Extract hostname from URL
   - Get site state via getSiteState(hostname)
   - Update badge accordingly

2. Set up chrome.tabs.onActivated listener:
   - Call updateBadgeForTab for newly activated tab
   - Handle errors (tab may not exist)

3. Set up chrome.tabs.onUpdated listener:
   - Listen for 'complete' status (page fully loaded)
   - Call updateBadgeForTab when URL changes
   - Filter out non-HTTP(S) URLs (chrome://, file://, etc.)

4. Implement broadcastStateChange(hostname) function:
   - Query all tabs with matching hostname
   - Send message to each tab's content script: { action: 'stateChanged', enabled: boolean }
   - Used when popup toggles state - all tabs of same site update

5. Add logging for all state changes:
   - Log when site state is updated
   - Log when badge is updated
   - Use LOG_PREFIX for all logs

6. Handle edge cases:
   - Invalid URLs (new tab, chrome:// pages)
   - Tabs without permissions
   - Storage quota exceeded errors

Implementation pattern for badge:
```javascript
// Enabled: clear badge (show colored icon only)
chrome.action.setBadgeText({ text: '', tabId });

// Disabled: show OFF badge
chrome.action.setBadgeText({ text: 'OFF', tabId });
chrome.action.setBadgeBackgroundColor({ color: '#999999', tabId });
```
  </action>
  <verify>
1. Open multiple tabs to gemini.google.com
2. Toggle state in popup (will be implemented in 04-03)
3. Verify all tabs receive stateChanged message via DevTools console
4. Switch between tabs and verify badge updates correctly
5. Navigate to new URL and verify badge updates
  </verify>
  <done>
- Badge updates automatically when switching tabs
- Badge updates when URL changes in a tab
- State changes broadcast to all tabs of the same site
- All edge cases handled gracefully
- Logging shows state changes and badge updates
  </done>
</task>

</tasks>

<verification>
1. Load extension in Chrome and check service worker console for initialization log
2. Open chrome://extensions -> service worker -> Console, verify no errors
3. Check Application -> Storage -> Sync to verify settings structure
4. Test message passing: In content script console, run:
   ```javascript
   chrome.runtime.sendMessage({ action: 'getSiteState', hostname: 'gemini.google.com' }, console.log)
   ```
5. Verify badge shows 'OFF' for disabled sites, nothing for enabled
</verification>

<success_criteria>
- Service worker initializes without errors
- chrome.storage.sync stores per-site settings correctly
- getSiteState returns correct enabled/theme values
- setSiteState persists changes and triggers badge update
- Badge shows 'OFF' for disabled sites, clean for enabled
- Tab switching updates badge correctly
- State changes broadcast to all matching tabs
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-state-management/04-01-SUMMARY.md`
</output>
