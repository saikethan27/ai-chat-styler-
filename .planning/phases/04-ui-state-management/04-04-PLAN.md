---
phase: 04-ui-state-management
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-03"]
files_modified:
  - content/inject.js
  - content/claude-markdown.css
autonomous: true

must_haves:
  truths:
    - "Content script checks per-site enabled state before applying styling"
    - "Toggle OFF immediately removes all styling classes and injected CSS"
    - "Theme override (light/dark) takes precedence over auto-detection"
    - "State changes from popup apply without page reload"
    - "Observer disconnects when disabled to prevent unnecessary processing"
  artifacts:
    - path: "content/inject.js"
      provides: "Content script with toggle OFF support and theme override"
      exports: ["disableStyling", "enableStyling", "applyThemeOverride"]
    - path: "content/claude-markdown.css"
      provides: "CSS with theme override classes (.force-light, .force-dark)"
      contains: [".force-light", ".force-dark"]
  key_links:
    - from: "content/inject.js"
      to: "background.js"
      via: "chrome.runtime.sendMessage on init"
      pattern: "getSiteState"
    - from: "popup/popup.js"
      to: "content/inject.js"
      via: "stateChanged and themeChanged messages"
      pattern: "stateChanged|themeChanged"
---

<objective>
Update content script to support toggle OFF functionality and theme override, enabling users to disable styling per-site and force light/dark themes.

Purpose: Complete the state management loop by making the content script respond to enable/disable toggles and theme overrides from the popup.
Output: Updated inject.js with disable/enable functionality and theme override support.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@content/inject.js
@content/claude-markdown.css

## Current State

Current inject.js:
- Initializes and applies styling automatically on page load
- Has message handlers for getStatus, enableDebug, disableDebug
- No support for toggle OFF or theme override
- No check for per-site enabled state

Current message handlers in inject.js:
```javascript
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getStatus') { ... }
  if (request.action === 'enableDebug') { ... }
  if (request.action === 'disableDebug') { ... }
  return true;
});
```

## Requirements to Implement

- POPUP-01 (content side): Respond to toggle OFF by removing styling
- POPUP-02 (content side): Apply theme override (light/dark)
- BKGD-02 (content side): Check per-site state on initialization

## Key Technical Details

- Content script must query background for initial state
- Styling removal must be complete: classes, injected styles, observer
- Theme override classes: .force-light, .force-dark on html or body
- Message handlers needed: stateChanged, themeChanged
- Re-enabling should re-run full initialization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state checking and toggle OFF support to inject.js</name>
  <files>content/inject.js</files>
  <action>
Update inject.js to support enable/disable toggle and state management:

Add these new variables and functions to inject.js (after the existing variable declarations):

```javascript
// ============================================================================
// State Management
// ============================================================================

let isEnabled = true;  // Current enabled state for this site
let injectedStyles = [];  // Track injected style elements for cleanup

/**
 * Check if extension is enabled for current site
 * Queries background service worker for per-site state
 */
async function checkEnabledState() {
  try {
    const hostname = window.location.hostname;
    const response = await chrome.runtime.sendMessage({
      action: 'getSiteState',
      hostname: hostname
    });

    isEnabled = response?.enabled !== false;  // Default to true
    logger.info('Extension enabled for this site:', isEnabled);

    return isEnabled;
  } catch (error) {
    logger.warn('Failed to check enabled state, defaulting to enabled:', error);
    isEnabled = true;
    return true;
  }
}

/**
 * Disable all styling on the page
 * Removes classes, injected styles, and disconnects observer
 */
function disableStyling() {
  logger.info('Disabling styling...');

  isEnabled = false;

  // 1. Disconnect observer to stop processing mutations
  disconnectObserver();

  // 2. Remove all injected style elements
  injectedStyles.forEach(styleId => {
    const style = document.getElementById(styleId);
    if (style) {
      style.remove();
      logger.debug('Removed style:', styleId);
    }
  });
  injectedStyles = [];

  // 3. Remove all styling classes from containers
  const styledContainers = document.querySelectorAll('.claude-ui-styled, .claude-styled');
  styledContainers.forEach(container => {
    container.classList.remove(
      'claude-ui-styled',
      'claude-styled',
      'claude-ui-dark',
      'claude-ui-enhanced',
      'claude-ui-thinking',
      'claude-ui-thinking-complete'
    );

    // Remove data attributes
    container.removeAttribute('data-claude-styled-at');
  });

  // 4. Remove element-level classes
  const styledElements = document.querySelectorAll(
    '.claude-ui-heading, .claude-ui-code, .claude-ui-table, .claude-ui-list'
  );
  styledElements.forEach(el => {
    el.classList.remove('claude-ui-heading', 'claude-ui-code', 'claude-ui-table', 'claude-ui-list');
  });

  // 5. Remove debug class from body
  document.body.classList.remove('claude-ui-debug');

  // 6. Remove status badge
  if (statusBadge) {
    statusBadge.remove();
    statusBadge = null;
  }

  // 7. Remove theme override classes
  document.documentElement.classList.remove('claude-force-light', 'claude-force-dark');
  document.body.classList.remove('claude-force-light', 'claude-force-dark');

  logger.info('Styling disabled successfully');
}

/**
 * Re-enable styling on the page
 * Re-runs initialization
 */
async function enableStyling() {
  logger.info('Enabling styling...');

  isEnabled = true;

  // Re-run initialization
  await initialize();

  logger.info('Styling enabled successfully');
}

/**
 * Track injected style element for later cleanup
 */
function trackInjectedStyle(styleId) {
  if (!injectedStyles.includes(styleId)) {
    injectedStyles.push(styleId);
  }
}
```

Now modify the existing injectCSS function to track styles:

```javascript
async function injectCSS(url) {
  try {
    const cssUrl = chrome.runtime.getURL(url);
    const response = await fetch(cssUrl);

    if (!response.ok) {
      logger.error('Failed to fetch CSS:', url);
      return;
    }

    const cssText = await response.text();

    // Create style element
    const style = document.createElement('style');
    const styleId = `claude-ui-${url.replace(/[^a-zA-Z0-9]/g, '-')}`;
    style.id = styleId;
    style.textContent = cssText;

    // Inject into document head
    const target = document.head || document.documentElement;
    if (target) {
      target.appendChild(style);
      trackInjectedStyle(styleId);  // Track for cleanup
    }

    logger.info('Injected CSS:', url);
  } catch (error) {
    logger.error('Error injecting CSS', url, error);
  }
}
```

Also update injectVisualIndicatorStyles to track its style:

```javascript
function injectVisualIndicatorStyles() {
  const styleId = 'claude-ui-visual-indicators';
  if (document.getElementById(styleId)) return;

  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = `...`;  // existing content

  document.head.appendChild(style);
  trackInjectedStyle(styleId);  // Track for cleanup
  logger.debug('Visual indicator styles injected');
}
```

Update the initialize function to check enabled state first:

```javascript
async function initialize() {
  logger.group('Initializing Claude UI Extension');

  try {
    // Check if enabled for this site FIRST
    const enabled = await checkEnabledState();
    if (!enabled) {
      logger.info('Extension disabled for this site, skipping initialization');
      logger.groupEnd();
      return;
    }

    // Rest of existing initialize function...
    injectVisualIndicatorStyles();
    createStatusBadge();
    currentAdapter = selectAdapter();
    // ... etc

  } catch (error) {
    logger.error('Initialization failed:', error);
    logger.groupEnd();
  }
}
```

These changes ensure:
1. Extension checks if enabled before initializing
2. All injected styles are tracked for cleanup
3. disableStyling removes everything cleanly
4. enableStyling can re-initialize from scratch
  </action>
  <verify>
1. Manually test disableStyling by calling it from console
2. Verify all .claude-* classes are removed
3. Verify injected style elements are removed
4. Verify observer is disconnected
5. Test enableStyling to ensure it re-initializes correctly
  </verify>
  <done>
- checkEnabledState queries background on init
- disableStyling removes all classes and injected styles
- enableStyling re-runs initialization
- All injected styles tracked for cleanup
- Extension skips initialization if disabled
  </done>
</task>

<task type="auto">
  <name>Task 2: Add theme override and message handlers to inject.js</name>
  <files>content/inject.js</files>
  <action>
Add theme override support and new message handlers to inject.js:

Add these functions after the state management functions:

```javascript
/**
 * Apply theme override (light/dark/auto)
 * @param {string} theme - 'auto', 'light', or 'dark'
 */
function applyThemeOverride(theme) {
  logger.info('Applying theme override:', theme);

  const html = document.documentElement;
  const body = document.body;

  // Remove existing override classes
  html.classList.remove('claude-force-light', 'claude-force-dark');
  body.classList.remove('claude-force-light', 'claude-force-dark');

  if (theme === 'light') {
    html.classList.add('claude-force-light');
    body.classList.add('claude-force-light');

    // Remove dark mode from all styled containers
    const containers = document.querySelectorAll('.claude-ui-dark');
    containers.forEach(c => c.classList.remove('claude-ui-dark'));

  } else if (theme === 'dark') {
    html.classList.add('claude-force-dark');
    body.classList.add('claude-force-dark');

    // Add dark mode to all styled containers
    const containers = document.querySelectorAll('.claude-ui-styled');
    containers.forEach(c => {
      if (!c.classList.contains('claude-ui-dark')) {
        c.classList.add('claude-ui-dark');
      }
    });
  }

  // For 'auto', we just removed the overrides - let natural detection take over
  if (theme === 'auto') {
    // Re-apply dark mode detection to all containers
    const containers = document.querySelectorAll('.claude-ui-styled');
    containers.forEach(container => {
      const isDark = currentAdapter?.detectDarkMode?.() || false;
      if (isDark) {
        container.classList.add('claude-ui-dark');
      } else {
        container.classList.remove('claude-ui-dark');
      }
    });
  }

  logger.info('Theme override applied:', theme);
}

/**
 * Check if there's a theme override and apply it
 * Called during initialization
 */
async function checkAndApplyThemeOverride() {
  try {
    const hostname = window.location.hostname;
    const response = await chrome.runtime.sendMessage({
      action: 'getSiteState',
      hostname: hostname
    });

    const theme = response?.theme || 'auto';
    if (theme !== 'auto') {
      applyThemeOverride(theme);
    }
  } catch (error) {
    logger.debug('No theme override to apply');
  }
}
```

Now update the message handler section to add new handlers:

```javascript
// ============================================================================
// Message Handler (Popup Communication)
// ============================================================================

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // Existing handlers
  if (request.action === 'getStatus') {
    const containers = document.querySelectorAll('.claude-ui-styled');
    const thinkingContainers = document.querySelectorAll('.claude-ui-thinking');
    const enhancedContainers = document.querySelectorAll('.claude-ui-enhanced');

    const status = {
      active: isEnabled && !!currentAdapter,
      adapter: currentAdapter?.name,
      containerCount: containers.length,
      thinkingCount: thinkingContainers.length,
      enhancedCount: enhancedContainers.length,
      darkMode: currentAdapter?.detectDarkMode?.() || false,
      url: window.location.href,
      hostname: window.location.hostname,
      debug: window.CLAUDE_UI_DEBUG
    };

    logger.debug('Status requested:', status);
    sendResponse(status);
    return true;
  }

  if (request.action === 'enableDebug') {
    window.CLAUDE_UI_DEBUG = true;
    localStorage.setItem('CLAUDE_UI_DEBUG', 'true');
    document.body.classList.add('claude-ui-debug');
    showStatusBadge();
    sendResponse({ debug: true });
    return true;
  }

  if (request.action === 'disableDebug') {
    window.CLAUDE_UI_DEBUG = false;
    localStorage.setItem('CLAUDE_UI_DEBUG', 'false');
    document.body.classList.remove('claude-ui-debug');
    sendResponse({ debug: false });
    return true;
  }

  // NEW: State change handler (toggle ON/OFF)
  if (request.action === 'stateChanged') {
    logger.info('Received state change:', request.enabled);

    if (request.enabled) {
      enableStyling();
    } else {
      disableStyling();
    }

    sendResponse({ success: true, enabled: request.enabled });
    return true;
  }

  // NEW: Theme change handler
  if (request.action === 'themeChanged') {
    logger.info('Received theme change:', request.theme);

    applyThemeOverride(request.theme);

    sendResponse({ success: true, theme: request.theme });
    return true;
  }

  return true;
});
```

Update the initialize function to apply theme override after styling:

```javascript
async function initialize() {
  logger.group('Initializing Claude UI Extension');

  try {
    // Check if enabled for this site FIRST
    const enabled = await checkEnabledState();
    if (!enabled) {
      logger.info('Extension disabled for this site, skipping initialization');
      logger.groupEnd();
      return;
    }

    // Inject visual styles
    injectVisualIndicatorStyles();

    // Create status badge
    createStatusBadge();

    // Select adapter for current site
    currentAdapter = selectAdapter();

    if (!currentAdapter) {
      logger.error('No adapter found');
      logger.groupEnd();
      return;
    }

    logger.info('Selected adapter:', currentAdapter.name);

    // Check if adapter should activate on this page
    if (!shouldActivate()) {
      logger.info('Adapter not activating on this page');
      logger.groupEnd();
      return;
    }

    logger.info('Adapter activating');

    // Apply debug mode class if enabled
    if (window.CLAUDE_UI_DEBUG) {
      document.body.classList.add('claude-ui-debug');
    }

    // Wait for initial delay
    const delay = currentAdapter.initialDelayMs || 200;
    await new Promise(resolve => setTimeout(resolve, delay));

    // Inject CSS
    await injectVariables();
    await injectMarkdownStyles();

    // Apply styling to existing containers
    styleMarkdownContainers(currentAdapter);

    // NEW: Apply theme override if set
    await checkAndApplyThemeOverride();

    // Set up observer for dynamic content
    setupMutationObserver();

    // Listen for dark mode changes
    const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    darkModeMediaQuery.addEventListener('change', () => {
      styleMarkdownContainers(currentAdapter);
    });

    // Show status badge
    updateStatusBadge();

    logger.info('Initialization complete');
    logger.groupEnd();
  } catch (error) {
    logger.error('Initialization failed:', error);
    logger.groupEnd();
  }
}
```

These additions provide:
1. applyThemeOverride function for forcing light/dark mode
2. checkAndApplyThemeOverride to apply saved theme on init
3. stateChanged message handler for toggle ON/OFF
4. themeChanged message handler for theme selection
5. Theme override classes applied to html and body elements
  </action>
  <verify>
1. Test theme override by calling applyThemeOverride('dark') from console
2. Verify .claude-force-dark class is added to html and body
3. Test applyThemeOverride('light') and verify classes change
4. Test applyThemeOverride('auto') and verify classes are removed
5. Send test messages from popup console to verify handlers work
  </verify>
  <done>
- applyThemeOverride adds/removes theme classes correctly
- stateChanged message handler enables/disables styling
- themeChanged message handler applies theme override
- Theme override applied during initialization
- All message handlers respond correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CSS for theme override classes</name>
  <files>content/claude-markdown.css</files>
  <action>
Add theme override CSS rules to claude-markdown.css:

Append these rules to the end of content/claude-markdown.css:

```css
/* ============================================================================
   Theme Override Classes
   Force light or dark mode regardless of system preference
   ============================================================================ */

/* Force Light Mode */
.claude-force-light,
.claude-force-light .claude-styled,
.claude-force-light .claude-ui-styled {
  --bg-primary: #faf9f7;
  --bg-secondary: #f5f5f5;
  --text-primary: #1a1a1a;
  --text-secondary: #6b6b6b;
  --border-color: #e5e5e5;
  --code-bg: #f5f5f5;
  --blockquote-border: #d97757;
  --table-header-bg: #f5f5f5;
  --table-border: #e5e5e5;
  --link-color: #d97757;
}

/* Force Dark Mode */
.claude-force-dark,
.claude-force-dark .claude-styled,
.claude-force-dark .claude-ui-styled {
  --bg-primary: #1a1a1a;
  --bg-secondary: #2a2a2a;
  --text-primary: #f5f5f5;
  --text-secondary: #a0a0a0;
  --border-color: #333333;
  --code-bg: #2a2a2a;
  --blockquote-border: #e8956c;
  --table-header-bg: #2a2a2a;
  --table-border: #333333;
  --link-color: #e8956c;
}

/* Ensure forced themes override container-specific dark mode */
.claude-force-light .claude-ui-dark {
  --bg-primary: #faf9f7 !important;
  --bg-secondary: #f5f5f5 !important;
  --text-primary: #1a1a1a !important;
  --text-secondary: #6b6b6b !important;
  --border-color: #e5e5e5 !important;
  --code-bg: #f5f5f5 !important;
  --blockquote-border: #d97757 !important;
  --table-header-bg: #f5f5f5 !important;
  --table-border: #e5e5e5 !important;
  --link-color: #d97757 !important;
}

.claude-force-dark .claude-ui-styled {
  /* Ensure dark mode is applied even without .claude-ui-dark class */
  --bg-primary: #1a1a1a;
  --bg-secondary: #2a2a2a;
  --text-primary: #f5f5f5;
  --text-secondary: #a0a0a0;
  --border-color: #333333;
  --code-bg: #2a2a2a;
  --blockquote-border: #e8956c;
  --table-header-bg: #2a2a2a;
  --table-border: #333333;
  --link-color: #e8956c;
}
```

These CSS rules:
1. Define CSS variable overrides for forced light mode
2. Define CSS variable overrides for forced dark mode
3. Use !important for force-light to override any inline dark mode styles
4. Ensure force-dark applies to all styled containers regardless of their individual dark mode detection

The theme override works by setting CSS custom properties at the html/body level, which cascade down to all styled containers.
  </action>
  <verify>
1. Add .claude-force-dark class to html element on a test page
2. Verify all styled containers switch to dark mode colors
3. Add .claude-force-light class and verify light mode
4. Remove both classes and verify auto-detection works again
  </verify>
  <done>
- Theme override CSS added to claude-markdown.css
- Force light mode variables defined
- Force dark mode variables defined
- Override rules use proper specificity
- CSS cascades to all styled containers
  </done>
</task>

</tasks>

<verification>
1. Load extension and navigate to Gemini or Kimi
2. Open popup and toggle OFF - verify styling is removed immediately
3. Toggle ON - verify styling returns
4. Change theme to Dark - verify dark mode applies regardless of site theme
5. Change theme to Light - verify light mode applies
6. Change theme to Auto - verify site detection resumes
7. Refresh page with toggle OFF - verify extension stays disabled
8. Refresh page with theme override - verify theme persists
</verification>

<success_criteria>
- Toggle OFF immediately removes all styling
- Toggle ON re-applies styling without page reload
- Theme override (light/dark) forces correct color scheme
- Theme Auto resumes automatic detection
- State persists across page reloads
- Observer disconnects when disabled (check performance)
- No console errors during toggle/theme operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-state-management/04-04-SUMMARY.md`
</output>
