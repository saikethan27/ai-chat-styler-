---
phase: 04-ui-state-management
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - popup/popup.js
autonomous: true

must_haves:
  truths:
    - "Popup loads current site state from background on open"
    - "Toggle ON/OFF immediately updates background state and content script"
    - "Theme selector changes theme and persists to storage"
    - "Status display updates in real-time from content script"
    - "Debug mode toggle works and persists via localStorage"
  artifacts:
    - path: "popup/popup.js"
      provides: "Popup interaction handling, state sync, and message passing"
      exports: ["loadSiteState", "toggleEnabled", "setTheme", "updateStatus"]
  key_links:
    - from: "popup/popup.js"
      to: "background.js"
      via: "chrome.runtime.sendMessage"
      pattern: "chrome\.runtime\.sendMessage"
    - from: "popup/popup.js"
      to: "content script"
      via: "chrome.tabs.sendMessage"
      pattern: "chrome\.tabs\.sendMessage"
---

<objective>
Implement popup JavaScript with state synchronization, toggle handling, theme selection, and real-time status updates.

Purpose: Connect the popup UI to the background service worker and content scripts, enabling user control over the extension.
Output: Fully functional popup.js that handles all user interactions and keeps state synchronized.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@popup/popup.js
@popup/popup.html
@background.js

## Current State

Current popup.js has basic structure:
- Gets current tab and queries content script for status
- Has updatePopupStatus() function
- Listens for debug toggle (but no actual toggle UI exists yet)
- Listens for messages from content script

Current inject.js message handling:
- getStatus: Returns adapter name, container counts, dark mode status
- enableDebug/disableDebug: Toggles debug mode via localStorage

Background.js from 04-01 provides:
- getSiteState(hostname): Returns { enabled, theme }
- setSiteState(hostname, settings): Persists settings
- getAllSettings(): Returns global settings

## Requirements to Implement

- POPUP-01: ON/OFF toggle functionality
- POPUP-02: Light/Dark theme selector
- POPUP-03: Status indicator with real-time updates

## Key Technical Details

- Message passing: popup <-> background <-> content script
- State changes must propagate to all tabs of same site
- Theme values: "auto" | "light" | "dark"
- Debug mode uses localStorage + URL param
- Console prefix: '[Claude UI Extension]'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement popup state management and background communication</name>
  <files>popup/popup.js</files>
  <action>
Replace popup.js with complete state management implementation:

```javascript
// Popup script for Claude UI/UX Extension
// Handles user interactions and state synchronization

const LOG_PREFIX = '[Claude UI Extension]';

// Current state
let currentTab = null;
let currentHostname = null;
let currentState = null;

// DOM element references (will be populated on load)
let elements = {};

/**
 * Initialize popup on DOM ready
 */
document.addEventListener('DOMContentLoaded', async () => {
  console.log(LOG_PREFIX, 'Popup opened');

  // Cache DOM element references
  cacheElements();

  // Set up event listeners
  setupEventListeners();

  // Load current tab and state
  await initializePopup();
});

/**
 * Cache DOM element references for performance
 */
function cacheElements() {
  elements = {
    // Site display
    currentSite: document.getElementById('current-site'),

    // Toggle
    enableToggle: document.getElementById('enable-toggle'),

    // Theme buttons
    themeAuto: document.getElementById('theme-auto'),
    themeLight: document.getElementById('theme-light'),
    themeDark: document.getElementById('theme-dark'),
    themeDescription: document.getElementById('theme-description'),

    // Status
    adapterName: document.getElementById('adapter-name'),
    containerCount: document.getElementById('container-count'),
    darkModeStatus: document.getElementById('dark-mode-status'),
    stateStatus: document.getElementById('state-status'),

    // Debug
    debugToggle: document.getElementById('debug-section-toggle'),
    debugContent: document.getElementById('debug-content'),
    debugMode: document.getElementById('debug-mode'),

    // Container
    popupContainer: document.querySelector('.popup-container')
  };
}

/**
 * Set up all event listeners
 */
function setupEventListeners() {
  // Enable/disable toggle
  elements.enableToggle?.addEventListener('change', handleToggleChange);

  // Theme buttons
  elements.themeAuto?.addEventListener('click', () => setTheme('auto'));
  elements.themeLight?.addEventListener('click', () => setTheme('light'));
  elements.themeDark?.addEventListener('click', () => setTheme('dark'));

  // Debug section toggle
  elements.debugToggle?.addEventListener('click', toggleDebugSection);

  // Debug mode checkbox
  elements.debugMode?.addEventListener('change', handleDebugModeChange);

  // Footer links
  document.getElementById('settings-link')?.addEventListener('click', (e) => {
    e.preventDefault();
    chrome.runtime.openOptionsPage?.() || alert('Settings page coming soon!');
  });

  document.getElementById('help-link')?.addEventListener('click', (e) => {
    e.preventDefault();
    chrome.tabs.create({ url: 'https://github.com/your-repo/claude-ui-extension#readme' });
  });
}

/**
 * Initialize popup with current tab info and state
 */
async function initializePopup() {
  try {
    // Get current tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    currentTab = tabs[0];

    if (!currentTab?.url) {
      showError('Cannot access this page');
      return;
    }

    // Extract hostname
    currentHostname = new URL(currentTab.url).hostname;
    elements.currentSite.textContent = currentHostname;

    // Load state from background
    await loadSiteState();

    // Query content script for status
    await queryContentScript();

  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to initialize popup:', error);
    showError('Failed to load extension state');
  }
}

/**
 * Load site state from background service worker
 */
async function loadSiteState() {
  try {
    const response = await chrome.runtime.sendMessage({
      action: 'getSiteState',
      hostname: currentHostname
    });

    currentState = response || { enabled: true, theme: 'auto' };

    // Update UI to match state
    updateUIFromState();

    console.log(LOG_PREFIX, 'Loaded state:', currentState);
  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to load state:', error);
    // Use defaults
    currentState = { enabled: true, theme: 'auto' };
    updateUIFromState();
  }
}

/**
 * Update all UI elements to match current state
 */
function updateUIFromState() {
  // Update toggle
  elements.enableToggle.checked = currentState.enabled;

  // Update theme buttons
  updateThemeButtons(currentState.theme);

  // Update disabled state styling
  if (currentState.enabled) {
    elements.popupContainer?.classList.remove('disabled');
    elements.stateStatus.textContent = 'Active';
    elements.stateStatus.className = 'status-value active';
  } else {
    elements.popupContainer?.classList.add('disabled');
    elements.stateStatus.textContent = 'Disabled';
    elements.stateStatus.className = 'status-value inactive';
  }
}

/**
 * Query content script for current status
 */
async function queryContentScript() {
  if (!currentTab?.id) return;

  try {
    const response = await chrome.tabs.sendMessage(currentTab.id, {
      action: 'getStatus'
    });

    updateStatusDisplay(response);

    // Also update debug checkbox state
    if (response?.debug !== undefined) {
      elements.debugMode.checked = response.debug;
    }
  } catch (error) {
    // Content script not loaded or no response
    console.log(LOG_PREFIX, 'Content script not available:', error.message);
    elements.adapterName.textContent = 'Not available';
    elements.containerCount.textContent = '-';
    elements.darkModeStatus.textContent = '-';
  }
}

/**
 * Update status display from content script response
 */
function updateStatusDisplay(status) {
  if (!status) return;

  elements.adapterName.textContent = status.adapter || 'Unknown';
  elements.containerCount.textContent = status.containerCount ?? '-';
  elements.darkModeStatus.textContent = status.darkMode ? 'Yes' : 'No';
}

/**
 * Handle enable/disable toggle change
 */
async function handleToggleChange(event) {
  const enabled = event.target.checked;

  console.log(LOG_PREFIX, 'Toggle changed:', enabled);

  // Update local state
  currentState.enabled = enabled;

  // Update UI immediately for responsiveness
  updateUIFromState();

  // Save to background
  try {
    await chrome.runtime.sendMessage({
      action: 'setSiteState',
      hostname: currentHostname,
      enabled: enabled
    });

    // Notify content script to apply/remove styling
    await notifyContentScript('stateChanged', { enabled });

  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to save state:', error);
    // Revert UI on error
    currentState.enabled = !enabled;
    updateUIFromState();
  }
}

/**
 * Set theme for current site
 */
async function setTheme(theme) {
  console.log(LOG_PREFIX, 'Theme changed:', theme);

  // Update local state
  currentState.theme = theme;

  // Update UI
  updateThemeButtons(theme);

  // Save to background
  try {
    await chrome.runtime.sendMessage({
      action: 'setSiteState',
      hostname: currentHostname,
      theme: theme
    });

    // Notify content script
    await notifyContentScript('themeChanged', { theme });

  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to save theme:', error);
  }
}

/**
 * Update theme button active states
 */
function updateThemeButtons(activeTheme) {
  const buttons = {
    auto: elements.themeAuto,
    light: elements.themeLight,
    dark: elements.themeDark
  };

  // Update button classes
  Object.entries(buttons).forEach(([theme, btn]) => {
    if (btn) {
      btn.classList.toggle('active', theme === activeTheme);
    }
  });

  // Update description
  const descriptions = {
    auto: 'Automatically detect site\'s color scheme',
    light: 'Always use light theme',
    dark: 'Always use dark theme'
  };

  if (elements.themeDescription) {
    elements.themeDescription.textContent = descriptions[activeTheme] || descriptions.auto;
  }
}

/**
 * Toggle debug section expand/collapse
 */
function toggleDebugSection() {
  const section = document.querySelector('.debug-section');
  section?.classList.toggle('open');
}

/**
 * Handle debug mode checkbox change
 */
async function handleDebugModeChange(event) {
  const enabled = event.target.checked;

  console.log(LOG_PREFIX, 'Debug mode:', enabled);

  if (!currentTab?.id) return;

  try {
    const action = enabled ? 'enableDebug' : 'disableDebug';
    await chrome.tabs.sendMessage(currentTab.id, { action });
  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to toggle debug mode:', error);
  }
}

/**
 * Notify content script of state changes
 */
async function notifyContentScript(action, data) {
  if (!currentTab?.id) return;

  try {
    await chrome.tabs.sendMessage(currentTab.id, {
      action,
      ...data
    });
  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to notify content script:', error);
  }
}

/**
 * Show error message in popup
 */
function showError(message) {
  elements.currentSite.textContent = message;
  elements.currentSite.style.color = '#d97757';
  elements.enableToggle.disabled = true;
}

/**
 * Listen for status updates from content script
 */
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'statusUpdate') {
    updateStatusDisplay(message.status);
  }
});
```

Key implementation details:
1. Cache DOM elements on load for performance
2. Initialize popup by getting current tab, loading state, querying content script
3. Handle toggle changes: update UI, save to background, notify content script
4. Handle theme selection: update buttons, save to background, notify content script
5. Debug section toggle uses CSS class manipulation
6. All async operations have error handling
7. State updates propagate to content script immediately
  </action>
  <verify>
1. Load extension and open popup
2. Check console for initialization log
3. Verify state loads from background (check toggle position matches stored state)
4. Test toggle: should update background and content script
5. Test theme buttons: should highlight selected theme
6. Test debug section expand/collapse
7. Check that status updates from content script display correctly
  </verify>
  <done>
- popup.js initializes on DOMContentLoaded
- Loads site state from background service worker
- Queries content script for real-time status
- Toggle changes update background and content script
- Theme selection persists and notifies content script
- Debug section expands/collapses
- All error cases handled gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add real-time status polling and message handling</name>
  <files>popup/popup.js</files>
  <action>
Extend popup.js with real-time status updates and improved message handling:

Add these functions to the existing popup.js:

```javascript
/**
 * Start polling for status updates while popup is open
 * This ensures the status display stays current with the page
 */
function startStatusPolling() {
  // Poll every 2 seconds while popup is open
  const pollInterval = setInterval(async () => {
    // Only poll if popup is visible (user hasn't closed it)
    if (document.hidden) return;

    try {
      await queryContentScript();
    } catch (error) {
      // Stop polling if content script is no longer available
      clearInterval(pollInterval);
    }
  }, 2000);

  // Store interval ID for cleanup
  window._statusPollInterval = pollInterval;
}

/**
 * Clean up polling when popup closes
 */
window.addEventListener('unload', () => {
  if (window._statusPollInterval) {
    clearInterval(window._statusPollInterval);
  }
});

/**
 * Handle visibility change (popup shown/hidden)
 */
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && currentTab?.id) {
    // Refresh status when popup becomes visible again
    queryContentScript();
  }
});
```

Then modify the initializePopup function to start polling:

```javascript
async function initializePopup() {
  try {
    // Get current tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    currentTab = tabs[0];

    if (!currentTab?.url) {
      showError('Cannot access this page');
      return;
    }

    // Extract hostname
    currentHostname = new URL(currentTab.url).hostname;
    elements.currentSite.textContent = currentHostname;

    // Load state from background
    await loadSiteState();

    // Query content script for status
    await queryContentScript();

    // Start polling for updates
    startStatusPolling();

  } catch (error) {
    console.error(LOG_PREFIX, 'Failed to initialize popup:', error);
    showError('Failed to load extension state');
  }
}
```

Also add a helper to format the adapter name for display:

```javascript
/**
 * Format adapter name for display
 */
function formatAdapterName(name) {
  const names = {
    'gemini': 'Gemini',
    'kimi': 'Kimi',
    'generic': 'Generic'
  };
  return names[name] || name || 'Unknown';
}
```

And update updateStatusDisplay to use it:

```javascript
function updateStatusDisplay(status) {
  if (!status) return;

  elements.adapterName.textContent = formatAdapterName(status.adapter);
  elements.containerCount.textContent = status.containerCount ?? '-';
  elements.darkModeStatus.textContent = status.darkMode ? 'Yes' : 'No';
}
```

These additions ensure:
1. Status updates every 2 seconds while popup is open
2. Polling stops when popup closes (cleanup)
3. Status refreshes immediately when popup regains visibility
4. Adapter names are formatted nicely (gemini -> Gemini)
  </action>
  <verify>
1. Open popup and watch status values
2. Navigate on the target page to trigger new content
3. Verify status updates within 2 seconds
4. Close and reopen popup, verify status refreshes immediately
5. Check console that polling stops when popup closes
  </verify>
  <done>
- Status polling runs every 2 seconds while popup is open
- Polling stops when popup closes
- Status refreshes when popup becomes visible
- Adapter names formatted for display
- No memory leaks from polling intervals
  </done>
</task>

</tasks>

<verification>
1. Load extension and click icon to open popup
2. Verify current site hostname displays correctly
3. Toggle ON/OFF and verify:
   - Background state updates (check storage)
   - Content script receives message
   - Badge updates to show 'OFF' when disabled
4. Change theme and verify:
   - Selected theme button highlights
   - Description updates
   - State persists in storage
5. Open target site with markdown, verify status shows:
   - Correct adapter name
   - Container count > 0
   - Dark mode Yes/No
6. Test debug section expand/collapse
7. Test debug mode checkbox (if content script supports it)
</verification>

<success_criteria>
- Popup loads current site state on open
- Toggle immediately updates background and content script
- Theme selection persists and updates UI
- Status displays update in real-time
- Debug section expands/collapses
- All state changes propagate correctly
- No console errors during normal usage
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-state-management/04-03-SUMMARY.md`
</output>
