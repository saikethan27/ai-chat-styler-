---
phase: 03-dynamic-content
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - content/observer.js
  - content/inject.js
autonomous: true

must_haves:
  truths:
    - "MutationObserver watches for new markdown containers"
    - "100ms debouncing prevents excessive restyling"
    - "Observer disconnects cleanly when extension is disabled"
    - "Performance monitoring shows < 1ms overhead per batch"
  artifacts:
    - path: "content/observer.js"
      provides: "MutationObserver module with debouncing"
      min_lines: 100
      exports: ["createObserver", "disconnectObserver", "getObserverStats"]
    - path: "content/inject.js"
      provides: "Integration with observer module"
      contains: "import from './observer.js'"
  key_links:
    - from: "content/inject.js"
      to: "content/observer.js"
      via: "module import"
      pattern: "import.*observer"
    - from: "content/observer.js"
      to: "currentAdapter.responseContainerSelector"
      via: "container discovery"
      pattern: "responseContainerSelector"
---

<objective>
Create a dedicated MutationObserver module (content/observer.js) that handles dynamic content with 100ms debouncing, performance monitoring, and clean disconnect capability.

Purpose: Extract observer logic from inject.js into a reusable module that can efficiently handle streaming content on Gemini and Kimi without causing performance issues.
Output: content/observer.js module with debounced mutation handling and performance metrics.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Current State
- inject.js has inline MutationObserver (lines 493-586)
- Debouncing is already implemented (100ms)
- Need to extract to dedicated module for better organization
- Need to add performance monitoring

## Decisions to Honor
- 100ms debounce (from Decisions Log: "Debounced observer 100ms")
- Console prefix standard: '[Claude UI Extension]'
- Logger utility with debug/info/warn/error levels
</context>

<tasks>

<task type="auto">
  <name>Create content/observer.js module</name>
  <files>content/observer.js</files>
  <action>
Create a new module content/observer.js that exports observer management functions.

Structure:
```javascript
/**
 * MutationObserver Module
 * Handles dynamic content detection with debouncing and performance monitoring
 */

// Performance tracking
const perfMetrics = {
  mutationCount: 0,
  batchCount: 0,
  totalProcessingTime: 0,
  avgProcessingTime: 0
};

let observer = null;
let debounceTimer = null;
let isObserving = false;
const DEBOUNCE_MS = 100; // From decisions log

/**
 * Create and start the MutationObserver
 * @param {Object} options - Configuration options
 * @param {Function} options.onContainersFound - Callback when new containers are found
 * @param {string} options.selector - CSS selector for containers to watch
 * @param {Function} options.logger - Logger instance
 * @returns {Object} Observer control interface
 */
export function createObserver(options) {
  // Implementation
}

/**
 * Disconnect the observer and clean up
 */
export function disconnectObserver() {
  // Implementation
}

/**
 * Get performance statistics
 * @returns {Object} Performance metrics
 */
export function getObserverStats() {
  // Implementation
}

/**
 * Reset performance statistics
 */
export function resetObserverStats() {
  // Implementation
}
```

Key features to implement:
1. Debounced mutation handling (100ms)
2. Container discovery using provided selector
3. Performance timing (start time before processing, end after)
4. Track mutation count, batch count, average processing time
5. Clean disconnect that stops observing and clears timers
6. Export functions: createObserver, disconnectObserver, getObserverStats, resetObserverStats

Use the logger from options for debug output with '[Claude UI Extension]' prefix.
  </action>
  <verify>File exists at content/observer.js with all exported functions</verify>
  <done>content/observer.js created with createObserver, disconnectObserver, getObserverStats, resetObserverStats exports</done>
</task>

<task type="auto">
  <name>Implement debounced mutation handling</name>
  <files>content/observer.js</files>
  <action>
Implement the debounced mutation handling logic in content/observer.js:

```javascript
function debounce(func, wait) {
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(debounceTimer);
      func(...args);
    };
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(later, wait);
  };
}

function handleMutations(mutations, options) {
  const startTime = performance.now();
  perfMetrics.mutationCount += mutations.length;
  perfMetrics.batchCount++;

  let shouldNotify = false;

  for (const mutation of mutations) {
    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = /** @type {HTMLElement} */ (node);
          // Check if added node matches or contains the selector
          if (element.matches?.(options.selector) ||
              element.querySelector?.(options.selector)) {
            shouldNotify = true;
            break;
          }
        }
      }
    }

    // Handle class changes (theme changes)
    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
      const target = /** @type {HTMLElement} */ (mutation.target);
      if (target.classList.contains('dark') ||
          target.classList.contains('claude-styled')) {
        shouldNotify = true;
      }
    }

    if (shouldNotify) break;
  }

  if (shouldNotify && options.onContainersFound) {
    options.onContainersFound();
  }

  const endTime = performance.now();
  const processingTime = endTime - startTime;
  perfMetrics.totalProcessingTime += processingTime;
  perfMetrics.avgProcessingTime =
    perfMetrics.totalProcessingTime / perfMetrics.batchCount;

  if (options.logger?.debug) {
    options.logger.debug(`Mutation batch processed: ${processingTime.toFixed(2)}ms`, {
      mutations: mutations.length,
      avgTime: perfMetrics.avgProcessingTime.toFixed(2) + 'ms'
    });
  }
}
```

Ensure the debounced function is created inside createObserver and uses the 100ms constant.
  </action>
  <verify>Code includes debounce function and handleMutations with performance timing</verify>
  <done>Debounced mutation handling implemented with 100ms delay and performance tracking</done>
</task>

<task type="auto">
  <name>Update inject.js to use observer module</name>
  <files>content/inject.js</files>
  <action>
Update content/inject.js to import and use the observer module:

1. Add import at the top (after adapter imports):
```javascript
import { createObserver, disconnectObserver, getObserverStats } from './observer.js';
```

2. Replace the existing setupMutationObserver function (lines 520-573) with:
```javascript
function setupMutationObserver() {
  // Disconnect any existing observer
  disconnectObserver();

  // Create new observer with current adapter config
  const observer = createObserver({
    selector: currentAdapter?.responseContainerSelector,
    onContainersFound: () => {
      logger.debug('New containers detected, re-applying styling');
      applyStyling();
    },
    logger: logger
  });

  // Store reference for cleanup
  window.__claudeUiObserver = observer;

  logger.info('MutationObserver set up');
}
```

3. Update the cleanup function (lines 578-586) to use disconnectObserver:
```javascript
function cleanup() {
  disconnectObserver();
  if (debounceTimer) {
    clearTimeout(debounceTimer);
  }
}
```

4. Remove the old observer variable declaration (line 496) and debounceTimer declaration (line 497) since they're now in observer.js.

5. Keep the existing debounce function in inject.js as it's used elsewhere, or ensure observer.js exports it if needed.
  </action>
  <verify>inject.js imports from observer.js and uses createObserver/disconnectObserver</verify>
  <done>inject.js updated to use observer module, old inline observer code removed</done>
</task>

</tasks>

<verification>
- [ ] content/observer.js exists with all required exports
- [ ] 100ms debouncing is implemented
- [ ] Performance metrics are tracked (mutation count, batch count, avg processing time)
- [ ] Observer disconnects cleanly
- [ ] inject.js imports and uses the observer module
- [ ] Console shows debug logs with processing times when debug mode is enabled
</verification>

<success_criteria>
1. content/observer.js module created with proper exports
2. Debouncing works (100ms delay between mutation batch and callback)
3. Performance monitoring shows < 1ms average processing time per batch
4. disconnectObserver() cleanly stops observation and clears timers
5. inject.js successfully integrates with observer module
6. No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-content/03-01-SUMMARY.md`
</output>
