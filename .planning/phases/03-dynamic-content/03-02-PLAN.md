---
phase: 03-dynamic-content
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - content/inject.js
  - content/observer.js
autonomous: true

must_haves:
  truths:
    - "Streaming content gets styled as it appears (no flicker)"
    - "New messages in multi-turn conversations are styled"
    - "Observer re-applies styling when new containers appear"
    - "Styles apply immediately when page loads"
  artifacts:
    - path: "content/inject.js"
      provides: "Streaming-aware styling with re-apply logic"
      contains: "applyStyling() called on new containers"
    - path: "content/observer.js"
      provides: "Container discovery and notification"
      contains: "onContainersFound callback"
  key_links:
    - from: "content/observer.js"
      to: "content/inject.js applyStyling()"
      via: "onContainersFound callback"
      pattern: "onContainersFound.*applyStyling"
    - from: "applyStyling()"
      to: "currentAdapter.responseContainerSelector"
      via: "querySelectorAll"
      pattern: "querySelectorAll.*responseContainerSelector"
---

<objective>
Enhance the styling system to handle streaming content smoothly - applying styles incrementally as content appears without waiting for streaming to complete, and ensuring new messages in conversations get styled immediately.

Purpose: Current implementation waits for streaming/thinking to complete before styling. This causes visible flicker and delay. We need to style content incrementally during streaming for better UX.
Output: Enhanced applyStyling() that handles partial content and streaming states gracefully.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Current State
- inject.js has applyStyling() that skips containers during streaming/thinking
- applyStylingToContainer() applies all styles at once
- For Gemini: waits for thinking to complete before styling
- For Kimi: waits for streaming to complete before styling

## Problem
This causes visible flicker - content appears unstyled, then suddenly gets styled when streaming completes.

## Solution
Apply base styles immediately, then enhance when streaming completes. Use a two-phase approach:
1. Immediate: Add .claude-styled class and basic styling
2. Enhanced: Add detailed element styling when streaming completes

## Decisions to Honor
- Scoped CSS approach: Use .claude-styled class
- Visual indicators: .claude-ui-styled class for debugging
- Logger utility with levels
</context>

<tasks>

<task type="auto">
  <name>Modify applyStyling for incremental streaming support</name>
  <files>content/inject.js</files>
  <action>
Modify the applyStyling() function in content/inject.js to support incremental styling during streaming:

Current logic (lines 384-457):
- If thinking/streaming: wait, then style
- If not: style immediately

New logic:
- Always apply base styling immediately (add .claude-styled, .claude-ui-styled)
- If thinking/streaming: set up watcher to apply enhanced styling when complete
- Apply enhanced styling immediately if not streaming

Update applyStyling() as follows:

```javascript
function applyStyling() {
  if (!currentAdapter) {
    logger.warn('No adapter selected');
    return;
  }

  logger.group('Applying styling');
  logger.info('Adapter:', currentAdapter.name);
  logger.info('Selector:', currentAdapter.responseContainerSelector);

  const containers = document.querySelectorAll(currentAdapter.responseContainerSelector);
  logger.info('Found containers:', containers.length);

  let styledCount = 0;
  let skippedCount = 0;
  let pendingCount = 0;

  containers.forEach((container, index) => {
    // Skip excluded elements
    if (isExcluded(container)) {
      logger.debug(`Container ${index}: excluded`);
      skippedCount++;
      return;
    }

    // Validate container (generic adapter)
    if (currentAdapter.validateContainer && !currentAdapter.validateContainer(container)) {
      logger.debug(`Container ${index}: failed validation`);
      skippedCount++;
      return;
    }

    // PHASE 1: Always apply base styling immediately
    const isNewContainer = !container.classList.contains('claude-ui-styled');
    if (isNewContainer) {
      logger.info(`Container ${index}: applying base styling`);
      applyBaseStyling(container);
      styledCount++;
    }

    // PHASE 2: Apply enhanced styling or set up watcher
    const isThinking = currentAdapter.handleThinkingState && currentAdapter.isThinking?.(container);
    const isStreaming = currentAdapter.isStreaming?.(container);

    if (isThinking) {
      logger.info(`Container ${index}: waiting for thinking to complete`);
      pendingCount++;
      currentAdapter.waitForThinkingComplete(container).then(() => {
        logger.info(`Container ${index}: thinking complete, applying enhanced styling`);
        applyEnhancedStyling(container);
        updateCounts();
      });
    } else if (isStreaming) {
      logger.info(`Container ${index}: streaming detected, will enhance when complete`);
      pendingCount++;
      currentAdapter.waitForStreamingComplete(container).then(() => {
        logger.info(`Container ${index}: streaming complete, applying enhanced styling`);
        applyEnhancedStyling(container);
        updateCounts();
      });
    } else {
      // Not streaming/thinking - apply enhanced styling immediately
      if (!container.classList.contains('claude-ui-enhanced')) {
        applyEnhancedStyling(container);
      }
    }
  });

  logger.info('Base styled:', styledCount, 'Skipped:', skippedCount, 'Pending:', pendingCount);
  logger.groupEnd();

  styledContainerCount += styledCount;
  updateStatusBadge();
}
```

Key changes:
1. Always call applyBaseStyling() for new containers (even during streaming)
2. Track pending containers waiting for thinking/streaming
3. Apply enhanced styling immediately if not streaming, or after streaming completes
  </action>
  <verify>applyStyling() now applies base styling immediately and handles streaming states separately</verify>
  <done>applyStyling() modified with two-phase styling approach</done>
</task>

<task type="auto">
  <name>Create applyBaseStyling function</name>
  <files>content/inject.js</files>
  <action>
Create a new function applyBaseStyling() in content/inject.js that applies immediate base styling:

```javascript
/**
 * Apply base styling immediately to a container
 * This is called even during streaming to prevent unstyled content
 * @param {HTMLElement} container
 */
function applyBaseStyling(container) {
  logger.debug('Applying base styling to container:', container);

  // Add styled classes
  if (!container.classList.contains('claude-styled')) {
    container.classList.add('claude-styled');
  }
  if (!container.classList.contains('claude-ui-styled')) {
    container.classList.add('claude-ui-styled');
  }

  // Apply dark mode detection immediately
  const isDark = currentAdapter?.detectDarkMode?.() || false;
  logger.debug('Dark mode detected:', isDark);

  if (isDark) {
    if (!container.classList.contains('claude-ui-dark')) {
      container.classList.add('claude-ui-dark');
    }
  } else {
    container.classList.remove('claude-ui-dark');
  }

  // Mark container with timestamp for debugging
  container.setAttribute('data-claude-styled-at', Date.now().toString());

  logger.debug('Base styling applied');
}
```

This function:
1. Adds the base styling classes immediately
2. Applies dark mode detection
3. Adds a timestamp attribute for debugging
4. Does NOT wait for streaming/thinking to complete

Place this function after the isExcluded() function (around line 295).
  </action>
  <verify>applyBaseStyling() function exists and applies base classes immediately</verify>
  <done>applyBaseStyling() created with immediate class application and dark mode detection</done>
</task>

<task type="auto">
  <name>Rename applyStylingToContainer to applyEnhancedStyling</name>
  <files>content/inject.js</files>
  <action>
Rename and refactor applyStylingToContainer() to applyEnhancedStyling() in content/inject.js:

Current function (lines 301-373) is named applyStylingToContainer and does both base and detailed styling.

Refactor to:
1. Rename to applyEnhancedStyling
2. Remove base styling (now handled by applyBaseStyling)
3. Add .claude-ui-enhanced class to track enhanced state
4. Keep detailed element styling (headings, code blocks, tables, lists)

```javascript
/**
 * Apply enhanced styling to a container
 * Called after streaming/thinking completes or immediately if not streaming
 * @param {HTMLElement} container
 */
function applyEnhancedStyling(container) {
  logger.debug('Applying enhanced styling to container:', container);

  // Mark as enhanced to prevent re-processing
  if (!container.classList.contains('claude-ui-enhanced')) {
    container.classList.add('claude-ui-enhanced');
  }

  // Style specific elements based on adapter selectors
  const { selectors } = currentAdapter || {};
  if (selectors) {
    // Style headings
    if (selectors.headings) {
      const headings = container.querySelectorAll(selectors.headings);
      headings.forEach(el => {
        if (!el.classList.contains('claude-ui-heading')) {
          el.classList.add('claude-ui-heading');
        }
      });
      if (headings.length) logger.debug('Styled headings:', headings.length);
    }

    // Style code blocks
    if (selectors.codeBlocks) {
      const codeBlocks = container.querySelectorAll(selectors.codeBlocks);
      codeBlocks.forEach(el => {
        if (!el.classList.contains('claude-ui-code')) {
          el.classList.add('claude-ui-code');
        }
      });
      if (codeBlocks.length) logger.debug('Styled code blocks:', codeBlocks.length);
    }

    // Style tables
    if (selectors.tables) {
      const tables = container.querySelectorAll(selectors.tables);
      tables.forEach(el => {
        if (!el.classList.contains('claude-ui-table')) {
          el.classList.add('claude-ui-table');
        }
      });
      if (tables.length) logger.debug('Styled tables:', tables.length);
    }

    // Style lists
    if (selectors.lists) {
      const lists = container.querySelectorAll(selectors.lists);
      lists.forEach(el => {
        if (!el.classList.contains('claude-ui-list')) {
          el.classList.add('claude-ui-list');
        }
      });
      if (lists.length) logger.debug('Styled lists:', lists.length);
    }
  }

  logger.info('Enhanced styling applied successfully');
}
```

Update all references:
- Line 429: Change applyStylingToContainer to applyEnhancedStyling
- Line 441: Change applyStylingToContainer to applyEnhancedStyling
- Line 448: Change applyStylingToContainer to applyEnhancedStyling
  </action>
  <verify>Function renamed to applyEnhancedStyling, base styling removed, .claude-ui-enhanced class added</verify>
  <done>applyStylingToContainer renamed to applyEnhancedStyling with enhanced-only logic</done>
</task>

<task type="auto">
  <name>Update observer callback for re-application</name>
  <files>content/observer.js, content/inject.js</files>
  <action>
Ensure the observer properly triggers re-styling when new containers appear:

In content/observer.js, verify the handleMutations function properly detects new containers:

```javascript
function handleMutations(mutations, options) {
  const startTime = performance.now();
  perfMetrics.mutationCount += mutations.length;
  perfMetrics.batchCount++;

  let shouldNotify = false;
  let newContainerCount = 0;

  for (const mutation of mutations) {
    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = /** @type {HTMLElement} */ (node);

          // Check if added node IS a container
          if (element.matches?.(options.selector)) {
            shouldNotify = true;
            newContainerCount++;
            break;
          }

          // Check if added node CONTAINS containers
          if (element.querySelector?.(options.selector)) {
            shouldNotify = true;
            newContainerCount++;
            break;
          }
        }
      }
    }

    // Handle class changes (theme changes)
    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
      const target = /** @type {HTMLElement} */ (mutation.target);
      if (target.classList.contains('dark') ||
          target.classList.contains('claude-styled')) {
        shouldNotify = true;
      }
    }

    if (shouldNotify) break;
  }

  if (shouldNotify && options.onContainersFound) {
    if (options.logger?.debug) {
      options.logger.debug(`New containers detected: ${newContainerCount}`);
    }
    options.onContainersFound();
  }

  // ... rest of performance tracking
}
```

In content/inject.js, verify setupMutationObserver passes the correct callback:

```javascript
function setupMutationObserver() {
  // Disconnect any existing observer
  disconnectObserver();

  // Create new observer with current adapter config
  const observer = createObserver({
    selector: currentAdapter?.responseContainerSelector,
    onContainersFound: () => {
      logger.debug('New containers detected, re-applying styling');
      applyStyling();
    },
    logger: logger
  });

  // Store reference for cleanup
  window.__claudeUiObserver = observer;

  logger.info('MutationObserver set up with selector:', currentAdapter?.responseContainerSelector);
}
```

The key is that applyStyling() will be called whenever new containers are detected, and it will:
1. Apply base styling to new containers immediately
2. Set up watchers for streaming/thinking if needed
3. Apply enhanced styling when appropriate
  </action>
  <verify>Observer correctly detects new containers and triggers applyStyling()</verify>
  <done>Observer callback properly configured to re-apply styling on new containers</done>
</task>

</tasks>

<verification>
- [ ] Base styling applies immediately (even during streaming)
- [ ] Enhanced styling applies after streaming/thinking completes
- [ ] New messages in conversations get styled automatically
- [ ] No visible flicker during streaming
- [ ] Console logs show "base styling" and "enhanced styling" phases
- [ ] .claude-ui-enhanced class is added to containers
</verification>

<success_criteria>
1. Content gets base styling (.claude-styled class) immediately when it appears
2. Enhanced styling (headings, code blocks, etc.) applies after streaming completes
3. New messages in multi-turn conversations are automatically styled
4. No visible flicker - content appears with base styles already applied
5. Console shows debug logs for both base and enhanced styling phases
6. Observer correctly triggers re-styling when new containers appear
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-content/03-02-SUMMARY.md`
</output>
