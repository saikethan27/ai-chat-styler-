---
phase: 03-dynamic-content
plan: 03
type: execute
wave: 2
depends_on: ['03-02']
files_modified:
  - content/inject.js
  - content/adapters/gemini.js
autonomous: true

must_haves:
  truths:
    - "Gemini thinking blocks are styled differently from final response"
    - "Thinking → done transition triggers re-styling"
    - "Observer detects thinking state changes"
    - "Final response gets full enhanced styling"
  artifacts:
    - path: "content/adapters/gemini.js"
      provides: "Thinking state detection and transition handling"
      contains: ["isThinking", "waitForThinkingComplete", "onThinkingComplete"]
    - path: "content/inject.js"
      provides: "Integration with thinking state transitions"
      contains: "handleThinkingTransition"
  key_links:
    - from: "content/inject.js"
      to: "geminiAdapter.waitForThinkingComplete"
      via: "Promise-based waiting"
      pattern: "waitForThinkingComplete.*then"
    - from: "geminiAdapter"
      to: "inject.js applyEnhancedStyling"
      via: "callback/onThinkingComplete"
      pattern: "onThinkingComplete|applyEnhancedStyling"
---

<objective>
Implement special handling for Gemini's thinking → done transition. Thinking blocks should have distinct styling, and when thinking completes, the final response should get full enhanced styling.

Purpose: Gemini shows a "thinking" state before the final response. We need to:
1. Style thinking blocks differently (more subtle/placeholder-like)
2. Detect when thinking completes
3. Apply full styling to the final response
4. Ensure smooth transition without flicker

Output: Enhanced Gemini adapter with thinking state callbacks and inject.js integration for smooth transitions.
</objective>

<execution_context>
@C:\Users\madha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\madha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Current State
- gemini.js has isThinking() and waitForThinkingComplete() methods
- inject.js calls waitForThinkingComplete() and then applies styling
- No distinct styling for thinking blocks vs final response

## Requirement OBSV-03
Handle "thinking" → "done" transitions on Gemini

## Decisions to Honor
- Style thinking blocks differently from final response (from Decisions Log)
- Scoped CSS approach
- Visual indicators for debugging
</context>

<tasks>

<task type="auto">
  <name>Add thinking state CSS classes</name>
  <files>content/inject.js</files>
  <action>
Add CSS for thinking state styling to the visual indicator styles in content/inject.js.

In the injectVisualIndicatorStyles() function (around line 64), add thinking-specific styles:

```javascript
function injectVisualIndicatorStyles() {
  const styleId = 'claude-ui-visual-indicators';
  if (document.getElementById(styleId)) return;

  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = `
    /* ... existing styles ... */

    /* Thinking state styling - more subtle */
    .claude-ui-thinking {
      opacity: 0.7;
      filter: grayscale(30%);
    }

    .claude-ui-thinking .claude-ui-heading {
      opacity: 0.8;
    }

    .claude-ui-thinking .claude-ui-code {
      opacity: 0.8;
    }

    /* Thinking indicator badge */
    .claude-ui-thinking::after {
      content: 'Thinking...';
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(217, 119, 87, 0.9);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: system-ui, -apple-system, sans-serif;
      z-index: 100;
      pointer-events: none;
    }

    /* Hide thinking indicator when enhanced styling applied */
    .claude-ui-enhanced::after {
      display: none;
    }

    /* Transition from thinking to done */
    .claude-ui-styled {
      transition: opacity 0.3s ease, filter 0.3s ease;
    }

    /* Debug mode: show thinking state */
    .claude-ui-debug .claude-ui-thinking {
      outline: 2px dashed #d97757 !important;
      outline-offset: 4px;
    }
  `;

  document.head.appendChild(style);
  logger.debug('Visual indicator styles injected (with thinking state)');
}
```

These styles:
1. Reduce opacity for thinking blocks (.claude-ui-thinking)
2. Add a "Thinking..." badge
3. Hide the badge when enhanced styling is applied
4. Add smooth transitions
5. Show debug outline in debug mode
  </action>
  <verify>Visual indicator styles include .claude-ui-thinking class and thinking badge</verify>
  <done>Thinking state CSS classes added to visual indicator styles</done>
</task>

<task type="auto">
  <name>Add thinking state handling to applyStyling</name>
  <files>content/inject.js</files>
  <action>
Update the applyStyling() function in content/inject.js to handle thinking states with distinct styling:

In the applyStyling() function (around line 384), update the thinking state handling:

```javascript
function applyStyling() {
  if (!currentAdapter) {
    logger.warn('No adapter selected');
    return;
  }

  logger.group('Applying styling');
  logger.info('Adapter:', currentAdapter.name);
  logger.info('Selector:', currentAdapter.responseContainerSelector);

  const containers = document.querySelectorAll(currentAdapter.responseContainerSelector);
  logger.info('Found containers:', containers.length);

  let styledCount = 0;
  let skippedCount = 0;
  let pendingCount = 0;

  containers.forEach((container, index) => {
    // Skip excluded elements
    if (isExcluded(container)) {
      logger.debug(`Container ${index}: excluded`);
      skippedCount++;
      return;
    }

    // Validate container (generic adapter)
    if (currentAdapter.validateContainer && !currentAdapter.validateContainer(container)) {
      logger.debug(`Container ${index}: failed validation`);
      skippedCount++;
      return;
    }

    // Check thinking/streaming state
    const isThinking = currentAdapter.handleThinkingState && currentAdapter.isThinking?.(container);
    const isStreaming = currentAdapter.isStreaming?.(container);

    // PHASE 1: Always apply base styling immediately
    const isNewContainer = !container.classList.contains('claude-ui-styled');
    if (isNewContainer) {
      logger.info(`Container ${index}: applying base styling`);
      applyBaseStyling(container);

      // Mark as thinking if in thinking state
      if (isThinking) {
        container.classList.add('claude-ui-thinking');
        logger.info(`Container ${index}: marked as thinking`);
      }

      styledCount++;
    }

    // PHASE 2: Handle thinking state transitions
    if (isThinking) {
      logger.info(`Container ${index}: waiting for thinking to complete`);
      pendingCount++;

      // Set up watcher for thinking completion
      currentAdapter.waitForThinkingComplete(container).then(() => {
        logger.info(`Container ${index}: thinking complete, transitioning to final`);

        // Remove thinking class
        container.classList.remove('claude-ui-thinking');

        // Apply enhanced styling
        applyEnhancedStyling(container);

        // Trigger transition animation
        handleThinkingTransition(container);

        updateCounts();
      });
    } else if (isStreaming) {
      logger.info(`Container ${index}: streaming detected, will enhance when complete`);
      pendingCount++;
      currentAdapter.waitForStreamingComplete(container).then(() => {
        logger.info(`Container ${index}: streaming complete, applying enhanced styling`);
        applyEnhancedStyling(container);
        updateCounts();
      });
    } else {
      // Not streaming/thinking - apply enhanced styling immediately
      if (!container.classList.contains('claude-ui-enhanced')) {
        applyEnhancedStyling(container);
      }
    }
  });

  logger.info('Base styled:', styledCount, 'Skipped:', skippedCount, 'Pending:', pendingCount);
  logger.groupEnd();

  styledContainerCount += styledCount;
  updateStatusBadge();
}
```

Key changes:
1. Mark container with .claude-ui-thinking class when in thinking state
2. Remove thinking class when thinking completes
3. Call handleThinkingTransition() for animation
4. Apply enhanced styling after thinking completes
  </action>
  <verify>applyStyling() adds .claude-ui-thinking class and removes it when thinking completes</verify>
  <done>applyStyling() updated with thinking state marking and transition handling</done>
</task>

<task type="auto">
  <name>Create handleThinkingTransition function</name>
  <files>content/inject.js</files>
  <action>
Create a new function handleThinkingTransition() in content/inject.js that handles the visual transition from thinking to done:

```javascript
/**
 * Handle the visual transition from thinking to done state
 * Adds a subtle animation to indicate content is now final
 * @param {HTMLElement} container
 */
function handleThinkingTransition(container) {
  logger.debug('Handling thinking transition for container:', container);

  // Add transition class for animation
  container.classList.add('claude-ui-thinking-complete');

  // Flash effect to indicate completion
  const flashOverlay = document.createElement('div');
  flashOverlay.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(217, 119, 87, 0.1), transparent);
    pointer-events: none;
    z-index: 10;
    animation: claude-thinking-flash 0.5s ease-out;
  `;

  // Add keyframes if not already present
  if (!document.getElementById('claude-thinking-animation')) {
    const style = document.createElement('style');
    style.id = 'claude-thinking-animation';
    style.textContent = `
      @keyframes claude-thinking-flash {
        0% { opacity: 0; transform: translateX(-100%); }
        50% { opacity: 1; }
        100% { opacity: 0; transform: translateX(100%); }
      }
    `;
    document.head.appendChild(style);
  }

  // Only add flash if container is positioned
  const computedStyle = window.getComputedStyle(container);
  if (computedStyle.position === 'static') {
    container.style.position = 'relative';
  }

  container.appendChild(flashOverlay);

  // Remove flash overlay after animation
  setTimeout(() => {
    flashOverlay.remove();
    container.classList.remove('claude-ui-thinking-complete');
  }, 500);

  // Update status badge with transition info
  if (statusBadge) {
    const originalText = statusBadge.textContent;
    statusBadge.textContent = 'Thinking complete ✓';
    statusBadge.classList.add('visible');

    setTimeout(() => {
      if (statusBadge) {
        statusBadge.textContent = originalText;
        if (!window.CLAUDE_UI_DEBUG) {
          statusBadge.classList.remove('visible');
        }
      }
    }, 2000);
  }

  logger.debug('Thinking transition animation applied');
}
```

This function:
1. Adds a subtle flash animation across the content
2. Updates the status badge to show "Thinking complete"
3. Cleans up after animation completes
4. Only runs when thinking transitions to done

Place this function after applyEnhancedStyling() (around line 375).
  </action>
  <verify>handleThinkingTransition() function exists with flash animation and status update</verify>
  <done>handleThinkingTransition() created with visual transition effects</done>
</task>

<task type="auto">
  <name>Enhance Gemini adapter with onThinkingComplete callback</name>
  <files>content/adapters/gemini.js</files>
  <action>
Enhance the geminiAdapter in content/adapters/gemini.js to support an optional onThinkingComplete callback:

Update the waitForThinkingComplete method to accept an optional callback:

```javascript
/**
 * Wait for thinking to complete before applying final styling
 * @param {HTMLElement} element
 * @param {Object} options - Options object
 * @param {Function} options.onComplete - Callback when thinking completes
 * @param {number} options.timeout - Maximum wait time in ms
 * @returns {Promise<void>}
 */
async waitForThinkingComplete(element, options = {}) {
  const { onComplete, timeout = 30000 } = options;

  if (!this.isThinking(element)) {
    if (onComplete) onComplete(element);
    return;
  }

  return new Promise((resolve) => {
    let resolved = false;

    const observer = new MutationObserver((mutations) => {
      if (!this.isThinking(element) && !resolved) {
        resolved = true;
        observer.disconnect();
        if (onComplete) onComplete(element);
        resolve();
      }
    });

    observer.observe(element, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['class', 'data-thinking-state']
    });

    // Timeout fallback
    setTimeout(() => {
      if (!resolved) {
        resolved = true;
        observer.disconnect();
        if (onComplete) onComplete(element);
        resolve();
      }
    }, timeout);
  });
},
```

Also add a new method for observing thinking state changes:

```javascript
/**
 * Observe thinking state changes on an element
 * @param {HTMLElement} element
 * @param {Object} callbacks - Callback functions
 * @param {Function} callbacks.onThinkingStart - Called when thinking starts
 * @param {Function} callbacks.onThinkingComplete - Called when thinking completes
 * @returns {MutationObserver} The observer instance
 */
observeThinkingState(element, callbacks = {}) {
  const { onThinkingStart, onThinkingComplete } = callbacks;

  const observer = new MutationObserver((mutations) => {
    const wasThinking = element.getAttribute('data-was-thinking') === 'true';
    const isThinking = this.isThinking(element);

    // Thinking started
    if (!wasThinking && isThinking && onThinkingStart) {
      element.setAttribute('data-was-thinking', 'true');
      onThinkingStart(element);
    }

    // Thinking completed
    if (wasThinking && !isThinking && onThinkingComplete) {
      element.removeAttribute('data-was-thinking');
      onThinkingComplete(element);
    }
  });

  // Set initial state
  element.setAttribute('data-was-thinking', this.isThinking(element).toString());

  observer.observe(element, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['class', 'data-thinking-state']
  });

  return observer;
},
```

These enhancements allow for more flexible thinking state handling with callbacks.
  </action>
  <verify>geminiAdapter.waitForThinkingComplete accepts onComplete callback, observeThinkingState method added</verify>
  <done>Gemini adapter enhanced with callback support and observeThinkingState method</done>
</task>

<task type="auto">
  <name>Update inject.js to use enhanced adapter methods</name>
  <files>content/inject.js</files>
  <action>
Update content/inject.js to optionally use the enhanced adapter methods with callbacks:

In applyStyling(), update the thinking state handling to use the onComplete callback:

```javascript
// PHASE 2: Handle thinking state transitions
if (isThinking) {
  logger.info(`Container ${index}: waiting for thinking to complete`);
  pendingCount++;

  // Use callback version if available, otherwise fall back to Promise
  if (currentAdapter.observeThinkingState) {
    // Set up observer that will trigger when thinking completes
    currentAdapter.observeThinkingState(container, {
      onThinkingComplete: (el) => {
        logger.info(`Container ${index}: thinking complete (via observer)`);

        // Remove thinking class
        el.classList.remove('claude-ui-thinking');

        // Apply enhanced styling
        applyEnhancedStyling(el);

        // Trigger transition animation
        handleThinkingTransition(el);

        updateCounts();
      }
    });
  } else {
    // Fall back to Promise-based waiting
    currentAdapter.waitForThinkingComplete(container, {
      onComplete: (el) => {
        logger.info(`Container ${index}: thinking complete (via promise)`);

        // Remove thinking class
        el.classList.remove('claude-ui-thinking');

        // Apply enhanced styling
        applyEnhancedStyling(el);

        // Trigger transition animation
        handleThinkingTransition(el);

        updateCounts();
      }
    });
  }
}
```

This provides:
1. Graceful fallback if observeThinkingState is not available
2. Immediate callback when thinking completes
3. Consistent handling regardless of adapter method used

Also update the message handler to include thinking state in status:

```javascript
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getStatus') {
    const containers = document.querySelectorAll('.claude-ui-styled');
    const thinkingContainers = document.querySelectorAll('.claude-ui-thinking');
    const enhancedContainers = document.querySelectorAll('.claude-ui-enhanced');

    const status = {
      active: !!currentAdapter,
      adapter: currentAdapter?.name,
      containerCount: containers.length,
      thinkingCount: thinkingContainers.length,
      enhancedCount: enhancedContainers.length,
      darkMode: currentAdapter?.detectDarkMode?.() || false,
      url: window.location.href,
      hostname: window.location.hostname
    };

    logger.debug('Status requested:', status);
    sendResponse(status);
  }
  // ... rest of handlers
});
```
  </action>
  <verify>inject.js uses enhanced adapter methods with callbacks and includes thinking count in status</verify>
  <done>inject.js updated to use enhanced adapter methods with callback support</done>
</task>

</tasks>

<verification>
- [ ] Thinking blocks have .claude-ui-thinking class and reduced opacity
- [ ] "Thinking..." badge appears on thinking blocks
- [ ] When thinking completes, badge disappears and full styling applies
- [ ] Flash animation plays on thinking → done transition
- [ ] Status badge shows "Thinking complete" briefly
- [ ] Console logs show thinking state detection and transition
- [ ] getStatus message includes thinkingCount and enhancedCount
</verification>

<success_criteria>
1. Gemini thinking blocks are styled with reduced opacity (.claude-ui-thinking class)
2. "Thinking..." badge appears on thinking blocks
3. When thinking completes, the transition is smooth with a flash animation
4. Final response gets full enhanced styling after thinking completes
5. Status updates show thinking state information
6. No flicker during thinking → done transition
7. Observer correctly detects and handles thinking state changes
</success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-content/03-03-SUMMARY.md`
</output>
