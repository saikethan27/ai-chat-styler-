---
plan_id: 02-03
phase: 02
wave: 2
title: Update inject.js for Adapter Loading
objective: Update content/inject.js to load appropriate adapter based on hostname matching
autonomous: true
depends_on: ['02-01', '02-02']
files_modified:
  - content/inject.js
---

# Plan 02-03: Update inject.js for Adapter Loading

## Objective
Update content/inject.js to dynamically load and use the appropriate site adapter based on hostname matching.

## Context
- inject.js currently exists from Phase 1
- Need to import all adapters (gemini, kimi, generic)
- Select adapter based on hostname matching
- Generic adapter is fallback for unmatched sites
- Priority: specific adapters > generic adapter

## Tasks

### Task 1: Import all adapters
**Type:** implementation
**File:** content/inject.js

Add imports at top of file:
```javascript
import geminiAdapter from './adapters/gemini.js';
import kimiAdapter from './adapters/kimi.js';
import genericAdapter from './adapters/generic.js';
```

### Task 2: Create adapter registry and selection logic
**Type:** implementation
**File:** content/inject.js

Add adapter registry:
```javascript
// Registry of all site adapters
const adapters = [
  geminiAdapter,
  kimiAdapter,
  genericAdapter // Must be last as fallback
];

// Select appropriate adapter for current site
function selectAdapter() {
  const hostname = window.location.hostname;

  // Find first matching adapter (specific adapters first)
  for (const adapter of adapters) {
    if (adapter.hostMatch && adapter.hostMatch.test(hostname)) {
      console.log(`[Claude UI Extension] Using adapter: ${adapter.name}`);
      return adapter;
    }
  }

  // Fallback to generic adapter
  console.log('[Claude UI Extension] Using generic adapter');
  return genericAdapter;
}

// Current adapter instance
let currentAdapter = null;
```

### Task 3: Update initialization to use adapter
**Type:** implementation
**File:** content/inject.js

Update init function:
```javascript
function init() {
  // Select adapter for current site
  currentAdapter = selectAdapter();

  if (!currentAdapter) {
    console.error('[Claude UI Extension] No adapter found');
    return;
  }

  // Check if adapter should activate on this page
  if (!shouldActivate()) {
    console.log('[Claude UI Extension] Adapter not activating on this page');
    return;
  }

  console.log(`[Claude UI Extension] Initializing ${currentAdapter.name} adapter`);

  // Apply initial styling
  applyStyling();

  // Set up mutation observer for dynamic content
  observeChanges();
}

// Determine if adapter should activate
function shouldActivate() {
  // Generic adapter: only activate if markdown containers found
  if (currentAdapter.name === 'generic') {
    const containers = document.querySelectorAll(currentAdapter.responseContainerSelector);
    if (containers.length === 0) {
      return false;
    }
    console.log(`[Claude UI Extension] Found ${containers.length} markdown containers`);
  }

  return true;
}
```

### Task 4: Update applyStyling to use adapter selectors
**Type:** implementation
**File:** content/inject.js

Update styling function:
```javascript
function applyStyling() {
  if (!currentAdapter) return;

  const containers = document.querySelectorAll(currentAdapter.responseContainerSelector);

  containers.forEach(container => {
    // Skip excluded elements
    if (isExcluded(container)) return;

    // Handle thinking state for Gemini
    if (currentAdapter.handleThinkingState && currentAdapter.isThinking?.(container)) {
      console.log('[Claude UI Extension] Waiting for thinking to complete');
      currentAdapter.waitForThinkingComplete(container).then(() => {
        applyStylingToContainer(container);
      });
      return;
    }

    // Handle streaming for Kimi
    if (currentAdapter.isStreaming?.(container)) {
      console.log('[Claude UI Extension] Waiting for streaming to complete');
      currentAdapter.waitForStreamingComplete(container).then(() => {
        applyStylingToContainer(container);
      });
      return;
    }

    applyStylingToContainer(container);
  });
}

function applyStylingToContainer(container) {
  // Add styled class
  container.classList.add('claude-ui-styled');

  // Apply dark mode detection
  const isDark = currentAdapter.detectDarkMode?.() || false;
  if (isDark) {
    container.classList.add('claude-ui-dark');
  }

  // Style specific elements based on adapter selectors
  const { selectors } = currentAdapter;
  if (selectors) {
    // Style headings
    if (selectors.headings) {
      container.querySelectorAll(selectors.headings).forEach(el => {
        el.classList.add('claude-ui-heading');
      });
    }

    // Style code blocks
    if (selectors.codeBlocks) {
      container.querySelectorAll(selectors.codeBlocks).forEach(el => {
        el.classList.add('claude-ui-code');
      });
    }

    // Style tables
    if (selectors.tables) {
      container.querySelectorAll(selectors.tables).forEach(el => {
        el.classList.add('claude-ui-table');
      });
    }

    // Style lists
    if (selectors.lists) {
      container.querySelectorAll(selectors.lists).forEach(el => {
        el.classList.add('claude-ui-list');
      });
    }
  }

  console.log('[Claude UI Extension] Styled container:', container);
}

function isExcluded(element) {
  if (!currentAdapter.excludeSelectors) return false;

  return currentAdapter.excludeSelectors.some(selector => {
    return element.matches(selector) || element.closest(selector);
  });
}
```

### Task 5: Update observer to use adapter selectors
**Type:** implementation
**File:** content/inject.js

Update observer configuration:
```javascript
function observeChanges() {
  const observer = new MutationObserver((mutations) => {
    let shouldRestyle = false;

    mutations.forEach(mutation => {
      // Check if any added nodes match our container selector
      mutation.addedNodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.matches?.(currentAdapter.responseContainerSelector) ||
              node.querySelector?.(currentAdapter.responseContainerSelector)) {
            shouldRestyle = true;
          }
        }
      });
    });

    if (shouldRestyle) {
      applyStyling();
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}
```

## Verification Criteria

- [ ] inject.js imports all adapters
- [ ] Adapter selection based on hostname works
- [ ] Generic adapter used as fallback
- [ ] shouldActivate prevents generic adapter on non-markdown pages
- [ ] applyStyling uses adapter-specific selectors

## must_haves (for goal-backward verification)

1. inject.js loads correct adapter based on hostname
2. Gemini adapter loads on gemini.google.com
3. Kimi adapter loads on kimi.ai
4. Generic adapter loads on other sites with markdown
5. Adapter selection is logged to console for verification
